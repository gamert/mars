// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MESSAGE_IO_FLAT_SPACEX_H_
#define FLATBUFFERS_GENERATED_MESSAGE_IO_FLAT_SPACEX_H_

#include "flatbuffers/flatbuffers.h"


namespace io {
namespace flat {
namespace SpaceX {

struct IdentifyI;
struct NetMessageI;
struct NetMessageO;
struct SyncTimeDTO;
struct PingTimeDTO;
struct LoginResultDTO;
struct GameZone;
struct ServiceAddress;

enum Channel {
  Channel_E_ERROR = 1,
  Channel_E_PM_DATA = 2,
  Channel_E_PM_UPDATE = 3,
  Channel_E_FETCH_PM = 4,
  Channel_E_START_SYNC_TIME = 31,
  Channel_E_SYNC_TIME = 32,
  Channel_E_PING_TIME = 33,
  Channel_MIN = Channel_E_ERROR,
  Channel_MAX = Channel_E_PING_TIME
};

inline const char **EnumNamesChannel() {
  static const char *names[] = { "E_ERROR", "E_PM_DATA", "E_PM_UPDATE", "E_FETCH_PM", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E_START_SYNC_TIME", "E_SYNC_TIME", "E_PING_TIME", nullptr };
  return names;
}

inline const char *EnumNameChannel(Channel e) { return EnumNamesChannel()[static_cast<int>(e) - static_cast<int>(Channel_E_ERROR)]; }

enum ErrorType {
  ErrorType_NO_MESSAGE = 0,
  ErrorType_AUTH_FAIL = 1,
  ErrorType_HAS_EXIST = 2,
  ErrorType_NO_GAME_ACCOUNT = 3,
  ErrorType_NOT_EXIST = 4,
  ErrorType_SERVER_ERROR = 5,
  ErrorType_MIN = ErrorType_NO_MESSAGE,
  ErrorType_MAX = ErrorType_SERVER_ERROR
};

inline const char **EnumNamesErrorType() {
  static const char *names[] = { "NO_MESSAGE", "AUTH_FAIL", "HAS_EXIST", "NO_GAME_ACCOUNT", "NOT_EXIST", "SERVER_ERROR", nullptr };
  return names;
}

inline const char *EnumNameErrorType(ErrorType e) { return EnumNamesErrorType()[static_cast<int>(e)]; }

enum GameNodeStatus {
  GameNodeStatus_OFFLINE = 0,
  GameNodeStatus_ONLINE = 1,
  GameNodeStatus_MAINTENANCE = 2,
  GameNodeStatus_MIN = GameNodeStatus_OFFLINE,
  GameNodeStatus_MAX = GameNodeStatus_MAINTENANCE
};

inline const char **EnumNamesGameNodeStatus() {
  static const char *names[] = { "OFFLINE", "ONLINE", "MAINTENANCE", nullptr };
  return names;
}

inline const char *EnumNameGameNodeStatus(GameNodeStatus e) { return EnumNamesGameNodeStatus()[static_cast<int>(e)]; }

struct IdentifyI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4,
    VT_TOKEN = 6,
    VT_USERID = 8,
    VT_MESSAGEUID = 10
  };
  int32_t pid() const { return GetField<int32_t>(VT_PID, 0); }
  const flatbuffers::Vector<int8_t> *token() const { return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOKEN); }
  int32_t userId() const { return GetField<int32_t>(VT_USERID, 0); }
  int32_t messageUId() const { return GetField<int32_t>(VT_MESSAGEUID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TOKEN) &&
           verifier.Verify(token()) &&
           VerifyField<int32_t>(verifier, VT_USERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEUID) &&
           verifier.EndTable();
  }
};

struct IdentifyIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) { fbb_.AddElement<int32_t>(IdentifyI::VT_PID, pid, 0); }
  void add_token(flatbuffers::Offset<flatbuffers::Vector<int8_t>> token) { fbb_.AddOffset(IdentifyI::VT_TOKEN, token); }
  void add_userId(int32_t userId) { fbb_.AddElement<int32_t>(IdentifyI::VT_USERID, userId, 0); }
  void add_messageUId(int32_t messageUId) { fbb_.AddElement<int32_t>(IdentifyI::VT_MESSAGEUID, messageUId, 0); }
  IdentifyIBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  IdentifyIBuilder &operator=(const IdentifyIBuilder &);
  flatbuffers::Offset<IdentifyI> Finish() {
    auto o = flatbuffers::Offset<IdentifyI>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<IdentifyI> CreateIdentifyI(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t pid = 0,
   flatbuffers::Offset<flatbuffers::Vector<int8_t>> token = 0,
   int32_t userId = 0,
   int32_t messageUId = 0) {
  IdentifyIBuilder builder_(_fbb);
  builder_.add_messageUId(messageUId);
  builder_.add_userId(userId);
  builder_.add_token(token);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct NetMessageI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHANNEL = 4,
    VT_IDENTIFY = 6,
    VT_PARAM = 8
  };
  int16_t channel() const { return GetField<int16_t>(VT_CHANNEL, 0); }
  const IdentifyI *identify() const { return GetPointer<const IdentifyI *>(VT_IDENTIFY); }
  const flatbuffers::Vector<int8_t> *param() const { return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PARAM); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CHANNEL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IDENTIFY) &&
           verifier.VerifyTable(identify()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARAM) &&
           verifier.Verify(param()) &&
           verifier.EndTable();
  }
};

struct NetMessageIBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(int16_t channel) { fbb_.AddElement<int16_t>(NetMessageI::VT_CHANNEL, channel, 0); }
  void add_identify(flatbuffers::Offset<IdentifyI> identify) { fbb_.AddOffset(NetMessageI::VT_IDENTIFY, identify); }
  void add_param(flatbuffers::Offset<flatbuffers::Vector<int8_t>> param) { fbb_.AddOffset(NetMessageI::VT_PARAM, param); }
  NetMessageIBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NetMessageIBuilder &operator=(const NetMessageIBuilder &);
  flatbuffers::Offset<NetMessageI> Finish() {
    auto o = flatbuffers::Offset<NetMessageI>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NetMessageI> CreateNetMessageI(flatbuffers::FlatBufferBuilder &_fbb,
   int16_t channel = 0,
   flatbuffers::Offset<IdentifyI> identify = 0,
   flatbuffers::Offset<flatbuffers::Vector<int8_t>> param = 0) {
  NetMessageIBuilder builder_(_fbb);
  builder_.add_param(param);
  builder_.add_identify(identify);
  builder_.add_channel(channel);
  return builder_.Finish();
}

struct NetMessageO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHANNEL = 4,
    VT_MESSAGEUID = 6,
    VT_DATA = 8
  };
  int16_t channel() const { return GetField<int16_t>(VT_CHANNEL, 0); }
  int32_t messageUId() const { return GetField<int32_t>(VT_MESSAGEUID, 0); }
  const flatbuffers::Vector<int8_t> *data() const { return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CHANNEL) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEUID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct NetMessageOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(int16_t channel) { fbb_.AddElement<int16_t>(NetMessageO::VT_CHANNEL, channel, 0); }
  void add_messageUId(int32_t messageUId) { fbb_.AddElement<int32_t>(NetMessageO::VT_MESSAGEUID, messageUId, 0); }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) { fbb_.AddOffset(NetMessageO::VT_DATA, data); }
  NetMessageOBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NetMessageOBuilder &operator=(const NetMessageOBuilder &);
  flatbuffers::Offset<NetMessageO> Finish() {
    auto o = flatbuffers::Offset<NetMessageO>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NetMessageO> CreateNetMessageO(flatbuffers::FlatBufferBuilder &_fbb,
   int16_t channel = 0,
   int32_t messageUId = 0,
   flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  NetMessageOBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_messageUId(messageUId);
  builder_.add_channel(channel);
  return builder_.Finish();
}

struct SyncTimeDTO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4
  };
  int64_t time() const { return GetField<int64_t>(VT_TIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct SyncTimeDTOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) { fbb_.AddElement<int64_t>(SyncTimeDTO::VT_TIME, time, 0); }
  SyncTimeDTOBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SyncTimeDTOBuilder &operator=(const SyncTimeDTOBuilder &);
  flatbuffers::Offset<SyncTimeDTO> Finish() {
    auto o = flatbuffers::Offset<SyncTimeDTO>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SyncTimeDTO> CreateSyncTimeDTO(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t time = 0) {
  SyncTimeDTOBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

struct PingTimeDTO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PING = 4
  };
  int32_t ping() const { return GetField<int32_t>(VT_PING, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PING) &&
           verifier.EndTable();
  }
};

struct PingTimeDTOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ping(int32_t ping) { fbb_.AddElement<int32_t>(PingTimeDTO::VT_PING, ping, 0); }
  PingTimeDTOBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PingTimeDTOBuilder &operator=(const PingTimeDTOBuilder &);
  flatbuffers::Offset<PingTimeDTO> Finish() {
    auto o = flatbuffers::Offset<PingTimeDTO>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PingTimeDTO> CreatePingTimeDTO(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t ping = 0) {
  PingTimeDTOBuilder builder_(_fbb);
  builder_.add_ping(ping);
  return builder_.Finish();
}

struct LoginResultDTO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4,
    VT_UID = 6,
    VT_TOKEN = 8,
    VT_LASTLOGIN = 10,
    VT_ZONES = 12
  };
  int32_t pid() const { return GetField<int32_t>(VT_PID, 0); }
  int32_t uid() const { return GetField<int32_t>(VT_UID, 0); }
  const flatbuffers::Vector<int8_t> *token() const { return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOKEN); }
  const ServiceAddress *lastLogin() const { return GetPointer<const ServiceAddress *>(VT_LASTLOGIN); }
  const flatbuffers::Vector<flatbuffers::Offset<GameZone>> *zones() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameZone>> *>(VT_ZONES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TOKEN) &&
           verifier.Verify(token()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LASTLOGIN) &&
           verifier.VerifyTable(lastLogin()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ZONES) &&
           verifier.Verify(zones()) &&
           verifier.VerifyVectorOfTables(zones()) &&
           verifier.EndTable();
  }
};

struct LoginResultDTOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) { fbb_.AddElement<int32_t>(LoginResultDTO::VT_PID, pid, 0); }
  void add_uid(int32_t uid) { fbb_.AddElement<int32_t>(LoginResultDTO::VT_UID, uid, 0); }
  void add_token(flatbuffers::Offset<flatbuffers::Vector<int8_t>> token) { fbb_.AddOffset(LoginResultDTO::VT_TOKEN, token); }
  void add_lastLogin(flatbuffers::Offset<ServiceAddress> lastLogin) { fbb_.AddOffset(LoginResultDTO::VT_LASTLOGIN, lastLogin); }
  void add_zones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameZone>>> zones) { fbb_.AddOffset(LoginResultDTO::VT_ZONES, zones); }
  LoginResultDTOBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LoginResultDTOBuilder &operator=(const LoginResultDTOBuilder &);
  flatbuffers::Offset<LoginResultDTO> Finish() {
    auto o = flatbuffers::Offset<LoginResultDTO>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<LoginResultDTO> CreateLoginResultDTO(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t pid = 0,
   int32_t uid = 0,
   flatbuffers::Offset<flatbuffers::Vector<int8_t>> token = 0,
   flatbuffers::Offset<ServiceAddress> lastLogin = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameZone>>> zones = 0) {
  LoginResultDTOBuilder builder_(_fbb);
  builder_.add_zones(zones);
  builder_.add_lastLogin(lastLogin);
  builder_.add_token(token);
  builder_.add_uid(uid);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct GameZone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ZONEID = 4,
    VT_ZONENAME = 6,
    VT_ADDRESS = 8,
    VT_STATUS = 10
  };
  int32_t zoneId() const { return GetField<int32_t>(VT_ZONEID, 0); }
  const flatbuffers::String *zoneName() const { return GetPointer<const flatbuffers::String *>(VT_ZONENAME); }
  const ServiceAddress *address() const { return GetPointer<const ServiceAddress *>(VT_ADDRESS); }
  GameNodeStatus status() const { return static_cast<GameNodeStatus>(GetField<int8_t>(VT_STATUS, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZONEID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ZONENAME) &&
           verifier.Verify(zoneName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.VerifyTable(address()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct GameZoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_zoneId(int32_t zoneId) { fbb_.AddElement<int32_t>(GameZone::VT_ZONEID, zoneId, 0); }
  void add_zoneName(flatbuffers::Offset<flatbuffers::String> zoneName) { fbb_.AddOffset(GameZone::VT_ZONENAME, zoneName); }
  void add_address(flatbuffers::Offset<ServiceAddress> address) { fbb_.AddOffset(GameZone::VT_ADDRESS, address); }
  void add_status(GameNodeStatus status) { fbb_.AddElement<int8_t>(GameZone::VT_STATUS, static_cast<int8_t>(status), 0); }
  GameZoneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameZoneBuilder &operator=(const GameZoneBuilder &);
  flatbuffers::Offset<GameZone> Finish() {
    auto o = flatbuffers::Offset<GameZone>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<GameZone> CreateGameZone(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t zoneId = 0,
   flatbuffers::Offset<flatbuffers::String> zoneName = 0,
   flatbuffers::Offset<ServiceAddress> address = 0,
   GameNodeStatus status = GameNodeStatus_OFFLINE) {
  GameZoneBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_zoneName(zoneName);
  builder_.add_zoneId(zoneId);
  builder_.add_status(status);
  return builder_.Finish();
}

struct ServiceAddress FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IP = 4,
    VT_PORT = 6
  };
  const flatbuffers::String *ip() const { return GetPointer<const flatbuffers::String *>(VT_IP); }
  int32_t port() const { return GetField<int32_t>(VT_PORT, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IP) &&
           verifier.Verify(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct ServiceAddressBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) { fbb_.AddOffset(ServiceAddress::VT_IP, ip); }
  void add_port(int32_t port) { fbb_.AddElement<int32_t>(ServiceAddress::VT_PORT, port, 0); }
  ServiceAddressBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ServiceAddressBuilder &operator=(const ServiceAddressBuilder &);
  flatbuffers::Offset<ServiceAddress> Finish() {
    auto o = flatbuffers::Offset<ServiceAddress>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ServiceAddress> CreateServiceAddress(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> ip = 0,
   int32_t port = 0) {
  ServiceAddressBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_ip(ip);
  return builder_.Finish();
}

}  // namespace SpaceX
}  // namespace flat
}  // namespace io

#endif  // FLATBUFFERS_GENERATED_MESSAGE_IO_FLAT_SPACEX_H_
